#include <bits/stdc++.h>

using namespace std;

// default values are temporary

/// @brief default seed used to the generation, if not specified
int DEFAULT_SEED = 2323;

/// @brief default multiplier used to the generation, if not specified
int DEFAULT_MULTIPLIER = 69; 

/// @brief default increment used to the generation, if not specified
int DEFAULT_INCREMENT = 13;

/// @brief default modulus used to the generation, if not specified
int DEFAULT_MODULUS = 29;

vector <double> RelFrequencyMap(vector <int> collection, int divisions, int lowest_value, int highest_value);
double Mean(vector <double> collection);
double Variance(vector <double> collection);
double DistributionHomogenity(vector <int> collection, int divisions, int lowest_value, int highest_value);


/// @brief simple linear congruential generator (LCG)
class SimpleLCGGenerator{
    public:
    /// @brief intial seed used in the generation process
    int Seed;
    /// @brief multiplier factor of the LCG
    int Multiplier; 
    /// @brief increment factor of the LCG
    int Increment;
    /// @brief modulus factor of the LCG
    int Modulus;

    /// @brief constructs the generator with all specified parameters
    /// @param seed intial seed used in the generation process
    /// @param multiplier multiplier factor of the LCG
    /// @param increment increment factor of the LCG
    /// @param modulus modulus factor of the LCG
    SimpleLCGGenerator(int seed, int multiplier, int increment, int modulus){
        Seed = seed;
        Multiplier = multiplier; 
        Increment = increment;
        Modulus = modulus;
    }

    /// @brief constructs the generator with default seed
    /// @param multiplier multiplier factor of the LCG
    /// @param increment increment factor of the LCG
    /// @param modulus modulus factor of the LCG
    SimpleLCGGenerator(int multiplier, int increment, int modulus){
        Seed = DEFAULT_SEED;
        Multiplier = multiplier; 
        Increment = increment;
        Modulus = modulus;
    }

    /// @brief constructs the generator with all default parameters
    SimpleLCGGenerator(){
        Seed = DEFAULT_SEED;
        Multiplier = DEFAULT_MULTIPLIER; 
        Increment = DEFAULT_INCREMENT;
        Modulus = DEFAULT_MODULUS;
    }

    public:
    /// @brief generates a list with n = size pseudo-random numbers, using a linear congruential generator (LCG)
    /// @param size size of the generated sequence
    /// @return vector <int> with the pseudo-random numbers
    vector <int> GenerateList(int size){
        vector <int> new_list;

        // takes the previous element as a seed to generate the next — seed updating by the Generate() method
        for(int i = 0; i < size; i++)
            new_list.push_back(Generate(Seed));

        return new_list;
    }

    public:
    /// @brief returns a pseudo-random number, using a linear congruential generator (LCG)
    /// @param seed intial seed used in the generation process
    /// @param multiplier multiplier factor of the LCG
    /// @param increment increment factor of the LCG
    /// @param modulus modulus factor of the LCG
    /// @return pseudo-random number generated by LCG
    int Generate(int seed){
        int new_number;
        new_number = ((seed * Multiplier) + Increment) % Modulus;
        Seed = new_number;
        return new_number;
    }

    public:
    /// @brief generates a pseudo-random number, using a linear congruential generator (LCG) (default seed)
    /// @param seed intial seed used in the generation process
    /// @param multiplier multiplier factor of the LCG
    /// @param increment increment factor of the LCG
    /// @param modulus modulus factor of the LCG
    /// @return pseudo-random number generated by LCG
    int Generate(){
        int new_number;
        new_number = ((Seed * Multiplier) + Increment) % Modulus;
        Seed = new_number;
        return new_number;
    }
};

/// @brief calculates the mean os the data collection
/// @param collection data collection for analysis
/// @return the mean of the collection (double)
double Mean(vector <double> collection){
    double mean = 0;
    for(int i = 0; i < collection.size(); i++){
        mean += collection[i]/(double)collection.size();
    }
    return mean;
}

/// @brief calculates the variance of a given data collection
/// @param collection data collection for analysis
/// @return the variance of the collection (double)
double Variance(vector <double> collection){
    double variance = 0;
    double mean = Mean(collection);
    for(int i = 0; i < collection.size(); i++){
        double quadratic_term = (collection[i] - mean)*(collection[i] - mean);
        variance += quadratic_term/(double)collection.size();
    }
    return variance;
}

/// @brief gives a factor for measure of the distribution homegenity, in a least squares method like strategy
/// @param collection the group of points
/// @param divisions number of divisions (bands)
/// @param lowest_value lowest value of the collection
/// @param highest_value highest value of the collection
/// @return factor of homegenity, bethween 0 and 1 (close to 1 means well distributed)
double DistributionHomogenity(vector <int> collection, int divisions, int lowest_value, int highest_value){
    double homogenity_factor = 0;
    vector <double> map = RelFrequencyMap(collection, divisions, lowest_value, highest_value);
    
    return 1 - Variance(map);
}

/// @brief generates the frequency map for the distribution
/// @param collection the group of points
/// @param divisions number of divisions (bands)
/// @param lowest_value lowest value of the collection
/// @param highest_value highest value of the collection
/// @return vector <double> with the relative frequêncies map of the collection
vector <double> RelFrequencyMap(vector <int> collection, int divisions, int lowest_value, int highest_value){
    vector <double> map;
    double step_size = (double)(highest_value - lowest_value)/(double)divisions;
    double individual_frequency = 1.0/collection.size();

    // initializes the map with n = divisions zeros
    for(int i = 0; i < divisions; i++){
        map.push_back(0);
    }

    // for every value of the data collection, adds one unit to the correspond band
    for(int i = 0; i < collection.size(); i++){
        int partition_index = (int)(collection[i]/step_size);
        map[partition_index] += individual_frequency;
    }

    return map;
}